#!/usr/bin/python3

from typing import List
from queue import Queue
import threading
import time
import socket
import configparser
import os
import importlib.util

# Get path to config directory and modules
XDG_CONFIG: str = os.getenv('XDG_CONFIG_HOME')
CONFIG_DIR: str = os.path.join(XDG_CONFIG, 'netmonitor')
MODULES_DIR: str = os.path.join(CONFIG_DIR, 'modules')
CONFIG_FILE: str = os.path.join(CONFIG_DIR, 'config.ini')
KNOWN_HOSTS: str = os.path.join(CONFIG_DIR, 'known_hosts.ini')
DEFAULT_RUN: bool = False

# Initialize Config object and read the config file
config = configparser.ConfigParser()
config.read(CONFIG_FILE)

# Get Unix socket and TCP port for remote connections from config
UNIX_SOCKET_PATH: str = config.get('DEFAULT', 'unix_socket_path')
REMOTE_PORT: int = config.getint('DEFAULT', 'remote_port')


def import_module(module_name, path):
    """
    Function that imports a module given a name and file path.
    """
    full_path = os.path.join(MODULES_DIR, path)
    print(full_path)

    # load the module
    spec = importlib.util.spec_from_file_location(module_name, full_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    return module


# Import custom modules
info = import_module('info', 'info.py')
commands = import_module('commands', 'commands.py')
promt_commands: List = commands.prompt_commands


def handle_client(connection, client):
    """
    Function that handles both local and remote connections to the program.
    Makes use of a TCP connection and Unix socket connection.
    """
    with connection:
        try:
            while True:
                data = connection.recv(1024).decode("utf-8")
                if not data:
                    info.log(f"[{client}] Client disconnected.")
                    break
                if data != "exit":
                    info.log(f"[{client}] Received data: {data}")
                    connection.sendall(b"Command received!")
                else:
                    info.log(f"[{client}] Client requested exit.")
                    break
        except (ConnectionResetError, BrokenPipeError):
            info.log(f"[{client}] Connection lost unexpectedly.")
        finally:
            info.log(f"[{client}] Closing connection.")


def unix_socket_server():
    if os.path.exists(UNIX_SOCKET_PATH):
        os.remove(UNIX_SOCKET_PATH)

    server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server_socket.bind(UNIX_SOCKET_PATH)
    server_socket.listen(1)  # Allow a single local connection
    info.log("[netmonitor] Listening on Unix socket...")

    while True:
        connection, addr = server_socket.accept()
        handle_client(connection, "Local")


def remote_socket_server():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('', REMOTE_PORT))
    server_socket.listen(5)  # Allow up to 5 remote connections
    info.log(f"[netmonitor] Listening for remote connections on port {
             REMOTE_PORT}...")

    while True:
        connection, addr = server_socket.accept()
        ip, port = addr
        handle_client(connection, f"{ip}:{port}")


# Main function
def main() -> None:
    """
    Main function to handle user input and manage threads.
    Uses prompt-toolkit for handling user input with auto-completion and
    ensures the prompt stays at the bottom of the terminal.
    """
    # Print the program name

    # List of threads responsible for running network tests
    test_threads: List[threading.Thread]

    """
    Create a Queue to hold formatted test results for output.
    Printing of results happens within this thread ONLY.
    Mainly to prevent any shenanigans that can happen with multiple threads
    printing at the same time.
    """
    output_queue: Queue = Queue()

    # Thread that handles output for generated by test threads.
    queue_thread: threading.Thread

    # Event to signal when threads to signal threads to stop when set.
    stop_event: threading.Event

    # queue_thread, test_threads, stop_event = generate_threads()

    # list of active connections (ip addr, port)
    active_connections: List = []

    # list of connections that are actively monitoring service checks
    active_monitors: List = []

    unix_thread = threading.Thread(target=unix_socket_server, daemon=True)
    remote_thread = threading.Thread(target=remote_socket_server, daemon=True)

    unix_thread.start()
    remote_thread.start()

    info.log("[netmonitor] Unix socket server and remote server are running.")

    # Keep the main thread running
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        info.log("[netmonotor] Shutting down...")
        if os.path.exists(UNIX_SOCKET_PATH):
            os.remove(UNIX_SOCKET_PATH)


if __name__ == "__main__":
    main()
